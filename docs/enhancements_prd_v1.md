# Codex-Go Enhancements PRD - v1.0 (Draft)

**Status:** Draft
**Date:** 2024-07-29
**Author:** Codex-Go Assistant (Gemini) & User

## 1. Introduction

This document outlines the requirements for the next phase of development for `codex-go`, a terminal-based AI coding assistant. These enhancements aim to improve the robustness, usability, security, and maintainability of the application, drawing inspiration from the analysis of the `codex-cli` (TypeScript) implementation.

## 2. Goals

*   Increase the reliability of core agent functions, particularly file patching and command execution.
*   Enhance the user experience through better feedback, logging, and approval mechanisms.
*   Improve the application's security posture through refined sandboxing controls.
*   Refactor core components for better maintainability and future extensibility.
*   Provide better debugging capabilities through structured logging.

## 3. Background

The initial version of `codex-go` successfully implements the core agent interaction loop, streaming responses, basic function calling (read/write/patch file, execute command, list directory), and a terminal UI using Bubble Tea.

An analysis of the `codex-cli` project revealed several areas where `codex-go` could be improved:

1.  **Patching Mechanism:** `codex-cli` uses a sophisticated custom patch format and parser, offering potentially more robustness than `codex-go`'s current reliance on the standard `patch` utility.
2.  **Execution/Approval Flow:** `codex-cli` has a more granular command approval process (including an "always approve" cache) and explicit sandbox configuration.
3.  **Agent State Management:** `codex-cli` includes more robust handling for cancellations, especially concerning pending tool calls.
4.  **Logging:** `codex-cli` utilizes structured, asynchronous file-based logging controlled by an environment variable.

This PRD details the requirements for implementing these improvements in `codex-go`.

## 4. Feature Requirements

### 4.1. Structured Logging

*   **Goal:** Implement a robust, configurable, and developer-friendly logging system.
*   **Requirements:**
    *   **Conditional Logging:** Logging should be disabled by default and enabled via a command-line flag (e.g., `--debug`) or environment variable.
    *   **File Output:** When enabled, logs should be written to a dedicated file, not `stderr`.
        *   The log file path should be configurable via a flag (e.g., `--log-file <path>`).
        *   A default log directory should be established (e.g., `~/.cache/codex-go/logs/` or platform equivalent).
        *   Log filenames should include a timestamp (e.g., `codex-go-YYYYMMDD-HHMMSS.log`).
    *   **Timestamped Entries:** Each log entry must be prefixed with a timestamp.
    *   **Asynchronous Logging:** Logging should be performed asynchronously (e.g., using channels and a dedicated goroutine) to avoid blocking the main application loop.
    *   **`latest.log` Symlink:** Create/update a symlink (e.g., `latest.log`) in the log directory pointing to the most recent log file for easy access (`tail -f`).
    *   **Integration:** Replace all existing `logDebug(...)` calls with the new logging mechanism.
    *   **Logger Interface:** Define a `Logger` interface and provide implementations for file logging and no-op logging.
    *   **Initial Log Level:** Start with a single "Debug" level for all messages. Granular levels (Info, Warn, Error) can be a future consideration.
*   **User Story:** As a developer using or debugging `codex-go`, I want detailed logs written asynchronously to a predictable file, controlled by a flag, so I can troubleshoot issues without impacting performance or cluttering my terminal.

### 4.2. Robust Patching

*   **Goal:** Significantly improve the reliability and flexibility of applying file patches generated by the LLM.
*   **Requirements:**
    *   **Custom Patch Parser:** Implement a new patching mechanism inspired by `codex-cli`. This involves:
        *   Defining a clear patch format (likely custom, similar to `codex-cli`'s `*** Begin Patch`, `*** Update File:`, `*** Add File:`, `*** Delete File:`, `+`, `-` lines) that the LLM will be instructed to use via the system prompt.
        *   Creating a Go parser for this custom format. The parser should handle file creation, deletion, and updates within a single patch block.
        *   Implementing fuzzy matching logic (similar to `codex-cli`'s `find_context`) to increase the chances of successfully applying patches even if the file has slightly diverged or the LLM's context lines aren't perfect.
    *   **Replace `patch_file`:** The existing `patch_file` function in `internal/functions` and its invocation should be replaced with this new mechanism. The corresponding `agent.FunctionDefinition` should be updated.
    *   **Clearer Error Feedback:** Provide specific error messages to the user and the agent if patch parsing or application fails (e.g., "Invalid patch format", "Context mismatch for hunk X in file Y").
*   **User Story:** As a user, when the agent generates code changes, I want `codex-go` to apply them reliably using a robust patching mechanism, even with minor discrepancies, and provide clear feedback on success or failure.

### 4.3. Refined Execution/Approval

*   **Goal:** Enhance the security, usability, and structure of shell command execution and user approvals.
*   **Requirements:**
    *   **Separation of Concerns:** Refactor the command execution logic currently within `App.handleAgentResponseItem`. Separate the approval/policy checks from the actual sandbox execution call.
    *   **"Always Approve" Cache:** Implement a session-specific cache. When the user approves a command via the UI prompt, offer an "Always Approve" option. If selected, store a key representing that command (e.g., derived from `deriveCommandKey` logic in `codex-cli`) and automatically approve subsequent identical commands for the rest of the session without prompting.
    *   **Explicit Sandbox Writable Roots:** Modify the `Sandbox.Execute` interface and implementation (`internal/sandbox/sandbox.go` and `bubblewrap` logic) to accept a list of specific host paths that should be writable *inside* the sandbox for a given command execution. Pass appropriate defaults (e.g., current working directory) but allow for future configuration.
    *   **(Optional) Retry on Sandbox Failure:** If a command executed *inside* the sandbox fails (non-zero exit code), optionally prompt the user if they want to retry executing the *exact same command* outside the sandbox. This should be configurable (e.g., via `Config.FullAutoErrorMode` similar to `codex-cli`).
    *   **Refactor Approval Logic:** Update the `askForApproval` UI function and the logic in `App` to accommodate the "Always Approve" option and the potential retry flow. Update `Config.ApprovalMode` handling if necessary.
*   **User Story:** As a user, I want finer-grained control over command approvals (approving once per session), improved security via explicit sandbox write controls, and the option to easily retry a failed sandboxed command unsandboxed if needed.

### 4.4. Improved Agent Loop State Management

*   **Goal:** Increase the robustness of the agent interaction loop, particularly around cancellation scenarios.
*   **Requirements:**
    *   **Handle Pending Aborts:** Implement logic to track tool calls that were received from the agent but whose execution was cancelled by the user before completion.
        *   When a user cancels (e.g., Ctrl+C during agent thinking or tool execution), identify any `FunctionCall` IDs that were pending execution.
        *   Store these pending `callID`s.
        *   In the *next* call to `Agent.SendMessage` or `Agent.SendFunctionResult`, include dummy/error `FunctionResult` messages for these stored `callID`s (e.g., output="execution cancelled by user", success=false) to satisfy the OpenAI API requirements and prevent errors.
    *   **Review Concurrency Control:** Re-evaluate the usage of `app.isAgentProcessing` and potentially add more robust locking or state checks if needed to prevent race conditions, especially around the asynchronous operations introduced by file logging and improved agent loop handling.
*   **User Story:** As a user, if I cancel an operation while the agent is working, I want the application to handle this gracefully without crashing or causing errors in subsequent interactions with the AI.

## 5. Non-Goals (For this Phase)

*   Major UI redesign or addition of new UI components beyond necessary prompts (e.g., for approval).
*   Adding fundamentally new agent capabilities or tools (focus is on refining existing ones).
*   Support for LLM providers other than OpenAI.
*   Full telemetry implementation.
*   Configuration file support (flags will be used initially).
*   Implementing multi-tool calls per LLM turn (can be considered later).

## 6. Open Questions

*   What specific Go library (or custom implementation) should be used for the robust patching logic? Research needed.
*   What is the exact desired custom patch format to instruct the LLM to use? Needs careful definition.
*   Should the "Retry on Sandbox Failure" feature be enabled by default?

## 7. Future Considerations

*   Granular log levels (Info, Warn, Error).
*   Allowing multiple tool calls per LLM turn.
*   Support for different sandbox technologies (Docker, etc.).
*   Loading configuration from a file (`codex.yaml`?). 